import os
import cv2
import numpy as np

from groundingdino.util.inference import load_model, load_image, predict


# =============================================================================
# CONFIG
# =============================================================================

def get_paths():
    """
    Resolve key paths relative to the current working directory.
    Assumes this file lives in the project root alongside GroundingDINO/.
    """
    cwd = os.getcwd()

    config_path = os.path.join(
        cwd,
        "GroundingDINO",
        "groundingdino",
        "config",
        "GroundingDINO_SwinT_OGC.py"
    )

    weights_path = os.path.join(
        cwd,
        "weights",
        "groundingdino_swint_ogc.pth"
    )

    return config_path, weights_path


# Your 3 class names and simple phrase-to-class mapping rules
CLASS_ID_TO_NAME = {
    0: "pilot_ladder",
    1: "ship_hull",
    2: "pilot_or_crew",
}

# We’ll use a single caption that mentions all concepts
TEXT_PROMPT = "pilot ladder, ship hull of large vessel, crew, pilot, seafarer, person on ship"

BOX_THRESHOLD = 0.35
TEXT_THRESHOLD = 0.25


# =============================================================================
# HELPER: phrase → class id
# =============================================================================

def phrase_to_class_id(phrase):
    """
    Map a GroundingDINO phrase to one of our 3 class IDs.

    Parameters
    ----------
    phrase : str
        Phrase string returned by GroundingDINO (e.g. "pilot ladder").

    Returns
    -------
    int or None
        0 for pilot_ladder, 1 for ship_hull, 2 for pilot_or_crew, or None if
        the phrase is not recognized as one of our classes.
    """
    p = phrase.lower()

    if "ladder" in p:
        return 0  # pilot_ladder

    # hull / ship side
    if "hull" in p or ("ship" in p and "hull" in p):
        return 1  # ship_hull

    # people near ladder / on ship
    if "crew" in p or "pilot" in p or "seafarer" in p or "person" in p or "man" in p or "woman" in p:
        return 2  # pilot_or_crew

    return None


# =============================================================================
# HELPER: Save YOLO txt (LabelImg-style)
# =============================================================================

def save_yolo_txt_from_dino(boxes, phrases, image_shape, label_path):
    """
    Convert GroundingDINO boxes + phrases into YOLO txt file.

    Parameters
    ----------
    boxes : np.ndarray
        Nx4 array of [x1, y1, x2, y2] in pixel coordinates.
    phrases : list[str]
        List of N phrases corresponding to the boxes.
    image_shape : tuple
        (H, W) of the original image.
    label_path : str
        Path to output .txt file.

    Notes
    -----
    - Writes YOLO format: <class_id> <x_center> <y_center> <width> <height>
      with all values normalized 0–1.
    """
    h, w = image_shape
    lines = []

    for box, phrase in zip(boxes, phrases):
        cls_id = phrase_to_class_id(phrase)
        if cls_id is None:
            continue

        x1, y1, x2, y2 = box  # pixel coords

        x_center = ((x1 + x2) / 2.0) / w
        y_center = ((y1 + y2) / 2.0) / h
        bw = (x2 - x1) / w
        bh = (y2 - y1) / h

        lines.append(f"{cls_id} {x_center:.6f} {y_center:.6f} {bw:.6f} {bh:.6f}")

    if lines:
        folder = os.path.dirname(label_path)
        os.makedirs(folder, exist_ok=True)
        with open(label_path, "w") as f:
            f.write("\n".join(lines))


# =============================================================================
# AUTO-LABEL N IMAGES WITH GROUNDING DINO
# =============================================================================

def auto_label_n_with_dino(model, input_dir, labels_dir, max_images=10):
    """
    Run GroundingDINO on up to N images in input_dir and write YOLO txt labels.

    Parameters
    ----------
    model : torch.nn.Module
        Loaded GroundingDINO model.
    input_dir : str
        Directory where images are stored (recursively).
    labels_dir : str
        Directory where YOLO txt labels will be written.
    max_images : int, optional
        Maximum number of images to process.

    Returns
    -------
    list[str]
        List of image paths that were processed.
    """
    exts = (".jpg", ".jpeg", ".png")
    image_paths = []

    for root, dirs, files in os.walk(input_dir):
        for f in files:
            if f.lower().endswith(exts):
                image_paths.append(os.path.join(root, f))

    print(f"Found {len(image_paths)} images. Using first {max_images}.")
    image_paths = image_paths[:max_images]

    from groundingdino.util.inference import load_image, predict

    for img_path in image_paths:
        # Relative path for label mirroring
        rel = os.path.relpath(img_path, input_dir)
        base_no_ext = os.path.splitext(rel)[0]
        label_path = os.path.join(labels_dir, base_no_ext + ".txt")

        # Load image in GroundingDINO format
        image_source, image = load_image(img_path)

        boxes, logits, phrases = predict(
            model=model,
            image=image,
            caption=TEXT_PROMPT,
            box_threshold=BOX_THRESHOLD,
            text_threshold=TEXT_THRESHOLD
        )

        # boxes are in cxcywh or xyxy depending on helper; Roboflow's wrapper returns xyxy in pixels
        # We assume boxes is Nx4 [x1, y1, x2, y2]
        boxes_np = boxes  # already numpy in Roboflow helper

        save_yolo_txt_from_dino(boxes_np, phrases, image_source.shape[:2], label_path)
        print(f"[LABEL] {img_path} -> {label_path}")

    return image_paths


# =============================================================================
# VISUALIZE LABELS FROM TXT
# =============================================================================

def visualize_from_txt(input_dir, labels_dir, vis_output_dir):
    """
    Draw bounding boxes from YOLO txt files on images and save visualizations.

    Parameters
    ----------
    input_dir : str
        Directory containing original images.
    labels_dir : str
        Directory containing YOLO txt label files.
    vis_output_dir : str
        Directory where annotated images will be written.
    """
    os.makedirs(vis_output_dir, exist_ok=True)

    exts = (".jpg", ".jpeg", ".png")
    class_colors = {
        0: (0, 255, 0),     # ladder
        1: (255, 0, 0),     # hull
        2: (0, 128, 255),   # crew
    }

    for root, dirs, files in os.walk(input_dir):
        for f in files:
            if not f.lower().endswith(exts):
                continue

            img_path = os.path.join(root, f)
            rel = os.path.relpath(img_path, input_dir)
            label_path = os.path.join(labels_dir, os.path.splitext(rel)[0] + ".txt")

            if not os.path.exists(label_path):
                continue

            img = cv2.imread(img_path)
            if img is None:
                continue

            h, w = img.shape[:2]

            with open(label_path, "r") as lf:
                lines = lf.readlines()

            for line in lines:
                cls, xc, yc, bw, bh = line.strip().split()
                cls = int(cls)
                xc, yc, bw, bh = float(xc), float(yc), float(bw), float(bh)

                x1 = int((xc - bw / 2) * w)
                y1 = int((yc - bh / 2) * h)
                x2 = int((xc + bw / 2) * w)
                y2 = int((yc + bh / 2) * h)

                cv2.rectangle(img, (x1, y1), (x2, y2), class_colors[cls], 2)
                cv2.putText(
                    img,
                    CLASS_ID_TO_NAME[cls],
                    (x1, max(0, y1 - 5)),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    0.6,
                    class_colors[cls],
                    2
                )

            out_path = os.path.join(vis_output_dir, f)
            os.makedirs(os.path.dirname(out_path), exist_ok=True)
            cv2.imwrite(out_path, img)
            print(f"[VIS] Saved: {out_path}")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    cwd = os.getcwd()
    print("CWD:", cwd)

    config_path, weights_path = get_paths()
    print("Config:", config_path)
    print("Weights:", weights_path)

    # Load GroundingDINO model
    model = load_model(config_path, weights_path)

    print("Working directory:", os.getcwd())
    cur_dir = os.getcwd()

    input_dir = os.path.join(cur_dir, "autolabel_images", "test_label_yoloe")
    labels_dir = os.path.join(cur_dir, "autolabel_images", "test_label_yoloe", "labels")
    vis_dir = os.path.join(cur_dir, "autolabel_images", "test_label_yoloe", "visual")

    # 1) Auto-label first 10 images
    auto_label_n_with_dino(model, input_dir, labels_dir, max_images=10)

    # 2) Visualize the labels we just wrote
    visualize_from_txt(input_dir, labels_dir, vis_dir)

    print("\nDONE.")
    print("Labels written to:     ", labels_dir)
    print("Visualizations written:", vis_dir)
